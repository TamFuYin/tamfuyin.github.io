---
layout: default
title: ZR NOIP 20连
permalink: /blog/zr-noip-20-lian/
---

# ZR20

Day1 ~ Day4 丢失了，沉重悼念。

~~有空补补~~

## Day5

100+0+0+0=100

如果暴力打满：100+0+20+25=145

### T1

赛时先写了一个抽象的 DFS，最后一个点跑了 80 多秒。

其实可以想想如何检验一个 ans 是否正确？

不难发现，由于一个数的质因分解是唯一的，所以可以 $O(m+\log V)$ 确定一个答案是否正确。

发现答案一定在一个很短的区间内，然后就做完了。

### T2

首先限制形如 $x_a\equiv x_b+c\pmod d$。

赛时思路是维护 $x\equiv f\pmod k$，其中 $f$ 是某个并查集的值，它可以自由选取 mod $k$ 同余系内的任何值。但是发现做不了。

我的疑问在于：并查集往往只能维护**相等的**值，但是对于**要求差为 $c$** 的条件该如何维护？

发现限制只有大概 15 种，且位数较高的限制严格强于位数较低的限制，即 $x_a\equiv x_b+c\pmod {d/2}$。

因此我们**不用**考虑不同位的限制如何合并，我们直接拆成 $1,2,\dots,\lg d$ 分别做就是对的。

对每一位维护一个带权并查集即可。

依然是代表元，但是每个元素约束的值等于代表元加上他到根的边权和。

~~用 LCT 也可以~~

### T3

只会 $A=B$，即哈夫曼树。

考虑倒过来操作，可以理解为初始时只有一个深度为 $0$ 的点，然后每次删除一个深度为 $x$ 的点，然后添加一个深度为 $x+1$ 和一个深度为 $x+2$ 的点。

如果一个深度序列已经确定，那么我们按从大到小把 $a$ 排序之后放入一定是最优的。

考虑每次操作一个允许操作的位置，对于不再操作的位置，直接计入答案即可。

然后你发现，待操作的位置至多只有两个，可以记下来！

考虑 DP，设 $f_{i,j,k,l}$ 表示 $i$ 和 $i+1$ 的数分别有 $j$ 和 $k$ 个，$1\sim i-1$ 总共有 $l$ 个，的最小代价。

$$
f_{i,j,k,l}+(p_{l+j-p}-p_l)i\to f_{i+1,k+p,p,l+j-p}
$$

这里 $p$ 代表 $a$ 的前缀和

然后就能做到 $O(N^5)$。

其实转移可以做到 $O(1)$。

可以延迟贡献，运用 $i=\sum_{j=1}^i1$ 的公式，每次 $i\to i+1$ 时把一个后缀和加进答案即可。

$$
f_{i,j,k,l}\to f_{i,j-1,k,l+1}\\
f_{i,j,k,l}+s_{l+1}\to f_{i+1,k+j,j,l}
$$

这样就能做到 $O(N^4)$。

注意到 $i$ 几乎是没用的，我们相当于做以下的操作 $+\infin$ 轮：

- $f_{j,k,l}\to f_{j-1,k,l+1}$
- $f_{j,k,l}+s_{l+1}\to g_{k+j,j,l}$
- 交换 $f,g$

由于是 $+\infin$，又是可以重复贡献的 ckmin，所以我们可以认为他是在进行
- $f_{j,k,l}\to f_{j-1,k,l+1}$
- $f_{j,k,l}+s_{l+1}\to f_{k+j,j,l}$

以任意顺序进行任意多次。

在完全背包中，我们是如何削减状态数的？通过从同一层已经转移的状态转移过来，从而把无穷大卷成了その $1$。

类似地，我们分别以 $l,j,k$ 为第一、二、三关键字的顺序转移，答案就是对的。

### T4

称一个串是合法的，如果对于所有 $a_i=a_j$，$a_{l+r-i}=a_{l+r-j}$。

然后答案就是所有合法串的 $m^{m-c}$ 之和，其中 $c$ 表示串的颜色数。

我会 $O(N^3)$！但是怎么没有部分分

其实很容易就能优化到 $O(N^2)$，然后拿到 20 pts 的高分，但是懒得写了。

赛时想了半天 $|A_i-A_{i+1}|=1$ 的部分分，但其实没有用？？

```c++
for(int i=1;i<=2*n-1;i++){
    for(int i=1;i<=n*2;i++) c[a[i]]=0;
    int cnt=0;
    for(int j=i;j>=1&&2*i-j<=2*n-1;j--){
        if(!a[j]) continue;
        if(!c[a[j]]) c[a[j]]=a[2*i-j],++cnt;
        else if(c[a[j]]!=a[2*i-j]) break;
        if(!c[a[2*i-j]]) c[a[2*i-j]]=a[j],++cnt;
        else if(c[a[2*i-j]]!=a[j]) break;
        (ans+=qpow(m,m-cnt))%=MOD;
    }
}
```

赛时觉得这个做法没什么前途，但其实你可以联想到**回文串**，因为这个东西基本长得跟数回文串贡献差不多一样。

他具有一个类似回文串的性质：对于一个合法子串 $[L,R]$，如果他的子串 $[l,r]$ 是合法的，那么他对应的串 $[L+R-r,L+R-l]$ 也是合法的。证明是简单的。

> 此题实际上是集训队论文《特殊等价关系下的字符串问题》中定义的字符串等价关系的一种

根据这个性质，我们可以做 Manacher！

设目前 $r$ 最大的回文串为 $[l,r]$，中心为 $k$，当前位置为 $i$。

设 $f_i$ 表示以 $i$ 为中心的回文半径，即最长回文串为 $[i-f_i+1,i+f_i-1]$

- 如果 $i+f_{2j-i}-1\le r$，那么 $f_i\gets f_{2j-i}$，然后继续拓展
- 否则，$f_i\gets r-i+1$

但是这个东西怎么继承呢？我们的颜色并非固定，所看重的只有等价关系。

可以维护从左边或者从右边开始碰到第一个没见过的颜色，然后每种颜色维护一个链表。

但是这里 $f_i\gets r-i+1$ 是一个 $f_{2j-i}$ 的历史信息，这里可以用一些可持久化数据结构维护。但是有神秘做法。

我们**直接继承** $2j-i$ 的信息，然后缩至 $r-i+1$，可以证明这个过程是均摊线性的。

（后面没看懂）

## Day6

100+28+0+0=128

### T1

签到题

### T2

赛时先想了一个很假的贪心，增增减减，过不了第 4 个大样例！

然后猜了一个结论：消去重复段和重复出现的形如 `121212` 模式之后，最优答案中间不会出现长度大于等于 7 的空格。

为什么是 7 呢？因为只有调到 7 能通过第 5 个大样例。

然后交上去只拿了 28 分，~~狗操的~~正睿怎么数据这么强啊！

实际上改一点就对了：两次之间不会出现超过 4 种与两个端点不同的颜色。

……等等我的结论貌似差不多**就是对的**，但是由于我没有从 $O(N^3)$ 的 DP 优化到 $O(N^2)$，也就是说没有注意到「只用记最大颜色和次大颜色」的结论，导致没有做出来，草

### T3

考虑把点分为 $<d/2$ 和 $\ge d/2$ 两部分，那么小点之间一定没有边，大点之间一定有边，所以我们只需要考虑小点和大点之间的边，即形如一个二分图。

神秘 trick：按照 $d,0,d-1,1,d-2,\dots$ 排序之后，每个小点与前面所有大点都有连边，且每个大点与前面所有小点都没有连边。因此维护当前染黑的大点数量即可 $O(N^2)$ DP。

……T3 果然大于 T2

### T4

记一个 $|\Sigma|\times |\Sigma|$ 的矩阵 $a_{i,j}$ 表示把颜色 $i$ 改成 $j$ 的数量。

那么 Edit 相当于选择 $x_1,x_2,y$，使 $a_{x_1,y}\gets a_{x_1,y}-1,a_{x_2,y}\gets a_{x_2,y}+1$

ChangeAll 相当于选择 $x_1,x_2$，对所有 $y$，使 $a_{x_2,y}\gets a_{x_2,y}+a_{x_1,y},a_{x_1,y}\gets 0$

我猜想如果 $|\Sigma|=2$，那么只会做一次 ChangeAll，然后我写了

```c++
...
printf("%d\n",std::min(a[0][1]+a[1][0],k+std::min(a[0][0]+a[1][0],a[0][1]+a[1][1])));
...
```

然后得到了零分的好成绩，为什么？？？

显然 Edit 操作一定会在 ChangeAll 后。

我们考虑做了若干次 ChangeAll 后，需要 Edit 的次数。

发现即为 $\sum_{i\ne j}a_{i,j}$。

考虑 ChangeAll 的过程，如果一次选择了 $u,v$，那么就连边一次 $u\to v$。

如果有连边 $u\to v,v\to w$，那么我们一定不会先做 $u\to v$ 再做 $v\to w$，因为不如做 $u\to w,v\to w$。

因此 $u\to v$ 就是 $u$ 最终去到的地方。

显然每个点的出度最多为 $1$，因此形如一个根向基环树森林。

贪心地想的话，怎样连边才是最优的？

显然对于每一行 $x$，我们找到它的最大值 $a_{x,p(x)}$，那么把它移到 $p(x)$ 一定是最优的。

因此我们得到一个基环树森林，我们希望断掉若干条边形成一个新的基环树森林。

一个决策的权值是怎样的？

对于有连边的点，其贡献为 $k+\sum_{i\ne p(x)}a_{x,i}=k+s_x-a_{x,p(x)}$，否则为 $s_x-a_{x,x}$。

直接取 $\min$ 即可。

~~但是这是错的，因为只有 DAG 我们才能按顺序操作。~~

但是你发现，只要他不是纯环，那么就可以操作。

具体的，假设环上一点 $x$ 有树边 $y\to x$，他在环上上一个点是 $z\to x$。

那么我们先操作 $z\to y$，就可以制造一个空位在环上操作，最后 $y\to x$，操作次数也是边数。

所以我们只需要考虑纯环的情况。

我们有三种决策：

- 连一个自环
- 连向一个不是纯环的连通块
- 连向另一个纯环

我们要求第 3 种决策不形成环。

由于至多只有 $|\Sigma|/2$ 个纯环，所以直接状压 DP 即可。

## Day7

100+100+25+0=225

期望：100+100+25+50=275

[REDACTED]的 T4 怎么直接就改题面了我还不知道我还以为改的只是

> 更新了 T4 的样例解释。

我[REDACTED] 50 pts 全没了啊！！！我[REDACTED]的 50 pts 全没了啊！！！:rage::rage::rage::sweat_smile::sweat_smile::sweat_smile:

赛前加强一下这一块，赛前加强一下还不告诉我这一块

### T1

签到题

### T2

瞪一下，发现形如 Ferrers 图，然后就 A 掉了

### T3

首先你发现题目给出的图形如一个二维偏序，可以定向为 DAG。

这种图被称为<ruby>可比性图<rt>Comparability Graph</rt></ruby>或偏序图。

我们可以证明其为<ruby>完美图<rt>Perfect Graph</rt></ruby>，即其任意导出子图都满足 $\chi(G)=\omega(G)$，即色数等于最大团的大小。

所以就是要求最大团 $\le 3$，即最长链 $\le 3$，即 LDS $\le 3$。

我的 AI 告诉我这道题可以用一些深刻的杨表结论表示。

其实是神秘的 DP。

没想到可以用那个经典的 lower bound 求 LIS 的算法，其实我此前一直不会这个算法。

这里换到求 LDS，就是维护一个递减序列，每次加入一个元素 $x$，就找到序列中第一个 $\le x$ 的位置覆盖掉，如果全部 $>x$ 就插入到末尾，最终序列即为 LDS。

从前往后加入每个数。设 $f_{i,j,k}$ 表示若当前维护的递减序列为 $(x,y,z)$，则还没有加入的数中，$(x,n]$ 有 $i$ 个，$(y,x)$ 有 $j$ 个，$(z,y)$ 有 $k$ 个，这样的长度为 $n-i-j-k$ 的前缀有多少个。

则可以转移到 $f_{u,i-u-1+j,k},u\in [0,i)$，$f_{i,v,j-v-1+k},v\in[0,j)$ 和 $f_{i,j,k-1}$。

可以前缀和优化到 $O(N^3)$。

对于字典序的限制，相当于钦定一个前缀，跟我们的 DP 是适配的。

### T4

赛时主要想着对 $a$ 搞笛卡尔树，怎么我最近好几道不是笛卡尔树的题都一直在想做笛卡尔树结果不会了呢？

后面想了想能不能扫描线做，发现形如在平面上放若干个平行四边形，好像做不了，最后写了暴力跑路。

upd: 其实是可以做的，只要把坐标系映射一下就变成了矩形加。然后变成区间加查询每个位置的绝对值历史 min。貌似做不了。

强化之后也是可以做的，但是要用猫树分治，区间加区间查询绝对值历史 min。貌似做不了。

但是题目在正式开赛前强化了一下，原题变成了性质 A，导致我一分没拿到，[REDACTED]。

其实可以 CDQ 分治。

设 $[L,R]$ 表示当前分治区间，中点为 $m$，考虑 $l\in[L,m],r\in(m,R]$ 的区间的贡献。

显然我们只在乎 $[L,m]$ 的 $a$ 和 $b$ 的后缀最小值，和 $(m,R]$ 的 $a$ 和 $b$ 的前缀最小值，分别记为 $la,lb,ra,rb$。

则区间 $[l,r]$ 的值即为 $|\min(la_l,ra_r)-\min(lb_l,rb_r)|$。

枚举 $l$，大分讨拆掉两个 $\min$，则合法的 $r$ 形如一段区间，相当于做区间 ckmin。因为是离线的，可以维护一个优先队列的差分，时间复杂度 $O(n\log^2 n)$，空间复杂度 $O(n\log n)$。

加强之后怎么做？考虑用类似线段树分治的做法，把询问分散到几个整区间内。

对每个整区间，都可以跑一遍优先队列前缀和。

但是可能会有跨区间的贡献。怎么办呢？考虑猫树分治。

考虑以 $k$ 为横坐标，$l$ 为纵坐标。

那么每次放的东西相当于在一条横线上 ckmin，然后每次询问相当于求一条纵线上的 min。

注意到横线之间甚至没有重叠，所以连优先队列前缀和都没有必要，用一个线段树辅助维护一下区间 min 即可。

~~然后就做完了。~~

我傻掉了，写的时候才发现、权值可能跟 $r$ 相关。

所以这个不是简单的 ckmin，是整个数组在各种意义下的位移之后 ckmin。那这个跟我一开始那个平行四边形有什么区别？？？

考虑对于一个 $k$，当 $l$ 移动时，答案的变化。

由于我们答案是分四类情况：

- 对于 $ra_r<la_l,rb_r<lb_l$，贡献 $|ra_r-rb_r|$ 仅与 $r$ 相关。所以只要预处理这个东西然后做一遍区间 min 即可。由于当 $l$ 向左移动时，$r$ 的左边界也向右移动，所以合法的位置一定形如一段区间。
- 对于 $ra_r>la_l,rb_r<lb_l$，贡献 $|la_l-rb_r|$。注意到当 $l$ 左移动时，$la_l$ 变小，$rb_r$ 变大，所以这个函数一定是单谷的，可以三分出来。然后求最接近这个谷的合法的 $r=l+k-1$ 即可。可以发现当 $l$ 向左移动时，$r$ 的左边界向右移动，右边界向左移动，也就是越来越不合法，所以合法的 $l$ 形如一段后缀。
- 对于 $ra_r<la_l,rb_r>lb_l$，类似第 2 种
- 对于 $ra_r>la_l,rb_r>lb_l$，贡献 $|la_l-lb_l|$ 仅与 $l$ 相关，所以只要看是否存在合法的 $r$ 即可。注意到对于一个 $k$，合法的 $l$ 必然形如一个前缀，取 min 即可。

这 94 大<ruby>分<rt>粪</rt></ruby>讨啊（喜

这里还有一个 $[L,R]$ 的限制，可以发现依然形如区间 min 的形式。

## Day8

我操我怎么挂完了

20+20+0+0=40...

何意味

怎么样例水得跟:shit:一样

### T1

赛时首先发现了一个必要条件：对于 1 链中任意三个连续的点，必然也在 2 链中连续。

然后我大胆猜想除了 $n\le 3$ 的情况，那么只有顺序和逆序两种情况是合法的。

但是是错的，充要条件是 $\forall i,|q_i-q_{i+1}|\le 2$。

他就不能多给几个样例吗……

### T2

正向考虑很难做，但是你发现除了 $a=b$ 的情况，那么只能做一种逆操作，形如辗转相减，可以辗转相除优化到 $\log V$，然后时间复杂度 $O(n\log n\log V)$，空间复杂度 $O(n\log V)$，这是怎么存得下的？这是怎么跑得过的？

出题人给的 `2000ms 512MB` 是他心胸的大小吗？开大一点会[REDACTED]吗？

而且出题人的样例是[REDACTED]故意造这么水的吗，怎么五个大样例都过了交上去第一个点就 WA 了？

upd: 拍了几千组没拍出来错误，不做了

### T3

考虑把他看成一个匹配问题：对于两棵树的非根节点，我们都需要匹配一条父边，然后就是对的。

现在边有两色，对于左部点，每种颜色的边匹配恰好一条，对于右部点，他只有两条连边，且从中选恰一条。

其实左部点的两种连边相独立，所以可以拆成两个点，所以现在左、右部都有 $2n-2$ 个点。

注意到由于右部点度数为 $2$，所以不妨「缩二度点」，直接给左部的两个点连边。

然后匹配哪个点可以看作给边定向，也就是要求每个点的出度为 $1$。特别的，如果是自环直接非法。

不难发现只有连边形如基环树时是合法的，且每个连通块有两种可能。

### T4

拼尽全力想出 $O(n\sqrt n\log n)$ 做法，结果假掉了。

不会离线做法导致的。

> 由于这太简单了

但是根本没想到。

考虑**倒过来**操作，然后就是区间 ckmin。

这启发我们维护**没出现过的数**。

考虑对于一个数 $x$，它的插入形如若干段区间覆盖。

那么对于每个 $x$，对于它的**没有被插入的区间**，我们在这些地方做 ckmin，然后维护区间 max。

但是每次插入 $x$，相当于撤销一段 ckmin 操作，怎么做？

考虑在每个线段树节点上挂一个可删堆，维护所有的整段 ckmin 标记，运用标记永久化的思想。然后就做完了……

## Day9

*ALL KILL!*

## Day10

期望：100+0+82+0=182

实际：100+0+48+0=148

### T1

打表找规律无果

考虑贪心倒着选一定是最优的。

赛时的思路是按照 $[2^{k-1},2^k-1]$ 分段，分别处理，应该也能做，但是麻烦。

考虑找到最小的 $2^k>r$，即 $r$ 所在段，则 $[2^k-r,r]$ 每个数选与不选是确定的，且与前面互不影响。

所以可以递归转移到 $[l,2^k-r-1]$。

### [T2](https://atcoder.jp/contests/yahoo-procon2018-qual/tasks/yahoo_procon2018_qual_d?lang=ja)

容易转化到 $Y=0$ 的情况。

考虑设 $x_{i,j}$ 表示 $(i,j)$ 是否异或上 $X$，那么我们计算 $A_{i,j}\oplus A_{i,j+1}\oplus A_{i+1,j}\oplus A_{i+1,j+1}$，查看等于 $0$ 还是 $X$，即得到 $x_{i,j}\oplus x_{i,j+1}\oplus x_{i+1,j}\oplus x_{i+1,j+1}$。

~~不难发现形如 4-SAT 问题，只要我们证明 P=NP 即可解决此题~~

---

完全没想到题解思路，赛时主要想着在行和列之间差分，没有想到在行内操作。

注意到 $A_{1,i}\oplus A_{1,j}=A_{i,j}(\oplus X)$，因此只要确定 $x_{1,i}$ 的值即可确定整个 $x$。

枚举 $a_1$，则 $A_{1,i}=a_1\oplus a_i(\oplus X)$，即 $a_i=a_1\oplus A_{1,i}(\oplus X)$，有两种选择。

注意现在各个 $a_i$ 基本是独立的，我们只要满足 $b$ 的限制即可。

先别急着上多项式，注意到 $\oplus X$ 是一个一对一映射，这意味着我们可以把整个值域一一配对，每对之间互相独立。

记 $t_x,x<x\oplus X$ 表示 $a_1\oplus A_{1,i}=x$ 的 $i$ 的数量，则贡献为 $\sum_{i=0}^{t_x}[t_x-i\le c_{x\oplus X}]\binom{t_x}{i}$，是一个二项式系数行内部分和的形式。

其中 $c_i$ 表示 $i$ 在 $b$ 中的出现次数。

直接枚举即做到 $O(n^2)$。

### T3

考虑递推式 $h_i=h_{i-1}-h_{i-2}$，将其表示为 $h_1$ 和 $h_2$ 的线性表示，手玩一下发现循环节为 $6$。

考虑 $x=h_1,y=h_2$，然后发现一个 $h_i$ 对答案 $(x,y)$ 的贡献，形如到一条直线的距离。

然后你发现若干条这样的东西加起来，答案肯定是凸的。

由于只有 $6$ 种斜率，对每种斜率，算出来夹在哪两条直线之间即可，三分套三分之后可以用树状数组维护。时间复杂度是 $O(q\log^3 V)$。

然而赛时由于三分没有处理负数的向下取整，而且有一个地方忘开 long long，导致 82 挂成 48。

为什么隔壁大佬同样的算法跑了 90 分……

---

实际上只有 $3$ 种贡献，另外 $3$ 种只要取个相反数即可。

如何规避三分？

通过简单的变换，可以把代价写作 $f_0(x)+f_1(y)+f_2(x+y)=\min_{z=x+y}f_2(z)+f_0(x)+f_1(y)$。

所以我们算出 $f_0$ 和 $f_1$ 的 min-plus 卷积即可。

每次修改需要把 $f_0,f_1$ 和 $f_2$ 加上一个绝对值函数，好像做不了。

记 $F(z)=\min_{z=x+y}f_2(z)+f_0(x)+f_1(y)$，显然 $F$ 是一个凸函数，我们只想求出它的谷。

如果三分其位置，那么每次需要求出 $G(z)=\min_{z=x+y}f_0(x)+f_1(y)$ 的值，比较难做。

我们不妨二分其位置对应的 $G(z)$ 的斜率，这样单点求值只需要求出 $f_0(x)$ 和 $f_1(x)$ 的斜率 $\le$ 它的边的向量和。同时一次性求出了横纵坐标。

这样可以做到两只 log

实际上三分并不好写，我们不妨二分求出 $F'(z)$ 的导数 $\le 0$ 的最大位置。

题解做法为什么是根号的？\bx <span style=color:red>S</span><span style=color:black>iyuan</span>

### T4

设 $f_{t,i}$ 表示跳了 $t$ 步之后位于点 $i$ 的方案数。

然后不会做了。

乾原来是看错题了，赛时以为题图形如一个高度为 $n$ 的满二叉树，其中根的高度为 $1$。

但是实际上是有 **取模** 的，所以 $\times 2\bmod N$ 就是循环移位，$\times 2+1\bmod N$ 是在循环移位的基础上再加 $1$。

如果连续操作 $n$ 次，会产生 $2^n$ 种可能，再总共的 $2^n-1$ 个节点中，只有它本身是本质不同的，所以可以猜测转移到它本身的方案数为 $2$；否则为 $1$。

暴力跳 $c\bmod n$ 步之后，需要乘上形如
$$
A=\begin{bmatrix}
    2&1&1&\cdots&1\\
    1&2&1&\cdots&1\\
    \vdots&\vdots&\vdots&\ddots&\vdots\\
    1&1&1&\dots&2\\
\end{bmatrix}^{\lfloor c/n\rfloor}
$$

的矩阵。

考虑组合意义，枚举乘了多少个 $2$，即得到
$$
A_{s,t}=\sum_{i=0}^{\lfloor c/n\rfloor-1}\binom{\lfloor c/n\rfloor}{i}2^iN^{\lfloor c/n\rfloor-i-1}=\frac{1}{N}((2+N)^{\lfloor c/n\rfloor}-2^{\lfloor c/n\rfloor})\\
$$

特别的，对于 $A_{s,s}$ 还要加上 $2^{\lfloor c/n\rfloor}$。

可以发现其实系数基本上是完全一样的。

现在考虑 $[l,r]$ 的贡献。

考虑拆贡献变成：枚举 $[l,r]$ 中每个 $i$ 和经过它的时间 $j$，计算从 $s$ 在 $j$ 步内走到 $i$ 的方案数乘上 $i$ 在 $c-j$ 步内走到 $t$ 的方案数。

为了适配我们的 $O(Nn)$ 的 DP，考虑先计算 $s$ 走 $j$ 步的 DP 数组，然后只保留 $[l,r]$ 的值，然后再走完剩下 $c-j$ 步。

由于后 $c-c\bmod n$ 步的贡献几乎是相同的，我们不妨合并为一项。

所以我们只用在每个 $j\bmod n$ 处把贡献在中间计算一下即可。

## Day11

100+15+100+0=215

### T1

宝宝题

### T2

操了这么唐的题怎么没想到，场上就差最后一步就做出来了。

记两个相邻点 $(x,y),(z,w)$ 的边权等于 $[a_{x,y}\ne a_{z,w}]$

场上转化为选择一条路径，使得路径上的边权和加上没有被选的点的颜色数最少。

然后我转化为选择若干段区间 $\{[l_i,r_i]\}$ 使得 $r_i+1<l_{i+1}$，上下两行交错选择，使得被选的总颜色数加上没有被选的边权和最少。然后我不会做这个，只写了 15 分特殊性质跑路。

但其实我转化错了：如果没有选的点的颜色出现路径上，且更靠后，其实我们是可以把它选掉的。

所以只需要看一下每个颜色最后出现的位置是否不在路径上即可。

### T3

注意到合法当且仅当 $\forall i\in S,a_i\nmid \operatorname{lcm}_{j\in S,j\ne i}a_j$

显然其满足区间包含单调性。所以双指针维护即可。

场上调了 3h，[REDACTED]

### T4

神秘题。

这种大概只能拆贡献，考虑枚举 $|i-j|$ 看他算了多少次。

由于 $x$ 相同的点是本质相同的，所以状态数比较少。

实际上我们只关心 $\sum_k [x_k=x_i],[q=i],[x_i=x_j]$，这三个值总共只有 $4n$ 种可能性。

不需要记 $[q=j]$ 是因为是对称的。

设这三个变量分别是 $a,b,c$，答案为 $f(a,b,c)$。

能否转移？显然终态即为 $f(n,0/1,1)$ 或 $f(0,0/1,1)$，其等于 $0$。

一次操作之后，会把 $x_j$ 的颜色翻转，并等概率随机选取一个 $k$ 进行转移，分四类：

- $k=j$
- $x_k=x_i$
- $k=i$
- $x_k\ne x_i$

讨论即可。

因此转移形如：

$$
\begin{aligned}
f(a, 0, 0)&= \frac{1}{n} f(n - a + 1, 1, 1) + \frac{a - 1}{n} f(a - 1, 0, 0)\\ &+ \frac{1}{n} f(a + 1, 0, 1) + [a < n] \frac{n - a - 1}{n} f(a + 1, 0, 0)\\
f(a, 1, 0)&= \frac{1}{n} f(n - a + 1, 1, 1) + \frac{a - 1}{n} f(a - 1, 0, 0)\\ &+ \frac{1}{n} (f(a + 1, 0, 1) + 1) + [a < n] \frac{n - a - 1}{n} f(a + 1, 0, 0)\\
f(a, 0, 1) &= \frac{1}{n} f(n - a + 1, 1, 0) + \frac{1}{n} f(a - 1, 0, 0)\\ &+ [a > 1]\frac{a - 2}{n} f(a - 1, 0, 1) + \frac{n - a}{n} f(a + 1, 0, 1)\\
f(a, 1, 1) &= \frac{1}{n} f(n - a + 1, 1, 0) + \frac{1}{n} (f(a - 1, 0, 0) + 1)\\ &+ [a > 1]\frac{a - 2}{n} f(a - 1, 0, 1) + \frac{n - a}{n} f(a + 1, 0, 1)\\
\end{aligned}
$$

然后可以注意到 $f(a,1,c)=f(a,0,c)+\frac 1 n$，所以可以变成 $2n$ 个变量。

$$
\begin{aligned}
f(a, 0)&= \frac{1}{n} f(n - a + 1, 1) + \frac{a - 1}{n} f(a - 1, 0)\\ &+ \frac{1}{n} f(a + 1, 1) + \frac{n - a - 1}{n} f(a + 1, 0) + \frac{1}{n ^ 2}\\
f(a, 1) &= \frac{1}{n} f(n - a + 1, 0) + \frac{1}{n} f(a - 1, 0)\\ &+ \frac{a - 2}{n} f(a - 1, 1) + \frac{n - a}{n} f(a + 1, 1) + \frac{1}{n ^ 2}\\
\end{aligned}
$$

进一步的可以注意到，事实上 $1<a<n$ 时 $f(a,0)=f(a,1)$，进一步的可以缩减到 $n$ 个变量。

$$
f_a = \frac{1}{n} f_{n - a + 1} + \frac{a - 1}{n} f_{a-1} +\frac{n - a }{n} f_{a + 1} + \frac{1}{n^2}
$$

设 $f_1=X,f_{n-1}=Y$，则可以递推一遍把所有变量表示成 $AX+BY+C$ 的形式，然后直接解出来，时间复杂度 $O(n)$。

最后每次修改和询问是简单的，时间 $O(n+q)$。

## Day12

气死我了，掉大分

怎么我几乎四道题都会但是全挂完了

### T1

其实赛时已经*几乎*想出了正解，但是由于没有建 Trie，而且证明不了充要，所以没有写。

说白了 T1 放这种贪心构造题的出题人就是[REDACTED]吧！

### T2

妈的我一开始看到 PA90 发现挂掉两个点面向数据编程了一下结果没过编译变成 CE0 了

我真的[REDACTED]了，出题人你[REDACTED]了。

### T3

这道题真的做过的。

考虑 $k$ 比较小，可以状压 DP。

否则，考虑按照 $1,k+1,2k+1,\dots,2,k+2,2k+2,\dots$ 的顺序加入，那么只用记一下每一段放的 $1$ 的个数即可。

### T4

妈的 NOIP 放个傻逼平衡树题出题人真的死妈了。

调了 INF 年没调出来交上去只有 32 分不如暴力。