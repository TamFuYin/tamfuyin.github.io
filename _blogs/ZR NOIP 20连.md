---
layout: default
title: ZR NOIP 20连
permalink: /blog/zr-noip-20-lian/
---

# ZR20

Day1 ~ Day4 丢失了，沉重悼念。

~~有空补补~~

## Day5

100+0+0+0=100

如果暴力打满：100+0+20+25=145

### T1

赛时先写了一个抽象的 DFS，最后一个点跑了 80 多秒。

其实可以想想如何检验一个 ans 是否正确？

不难发现，由于一个数的质因分解是唯一的，所以可以 $O(m+\log V)$ 确定一个答案是否正确。

发现答案一定在一个很短的区间内，然后就做完了。

### T2

首先限制形如 $x_a\equiv x_b+c\pmod d$。

赛时思路是维护 $x\equiv f\pmod k$，其中 $f$ 是某个并查集的值，它可以自由选取 mod $k$ 同余系内的任何值。但是发现做不了。

我的疑问在于：并查集往往只能维护**相等的**值，但是对于**要求差为 $c$** 的条件该如何维护？

发现限制只有大概 15 种，且位数较高的限制严格强于位数较低的限制，即 $x_a\equiv x_b+c\pmod {d/2}$。

因此我们**不用**考虑不同位的限制如何合并，我们直接拆成 $1,2,\dots,\lg d$ 分别做就是对的。

对每一位维护一个带权并查集即可。

依然是代表元，但是每个元素约束的值等于代表元加上他到根的边权和。

~~用 LCT 也可以~~

### T3

只会 $A=B$，即哈夫曼树。

考虑倒过来操作，可以理解为初始时只有一个深度为 $0$ 的点，然后每次删除一个深度为 $x$ 的点，然后添加一个深度为 $x+1$ 和一个深度为 $x+2$ 的点。

如果一个深度序列已经确定，那么我们按从大到小把 $a$ 排序之后放入一定是最优的。

考虑每次操作一个允许操作的位置，对于不再操作的位置，直接计入答案即可。

然后你发现，待操作的位置至多只有两个，可以记下来！

考虑 DP，设 $f_{i,j,k,l}$ 表示 $i$ 和 $i+1$ 的数分别有 $j$ 和 $k$ 个，$1\sim i-1$ 总共有 $l$ 个，的最小代价。

$$
f_{i,j,k,l}+(p_{l+j-p}-p_l)i\to f_{i+1,k+p,p,l+j-p}
$$

这里 $p$ 代表 $a$ 的前缀和

然后就能做到 $O(N^5)$。

其实转移可以做到 $O(1)$。

可以延迟贡献，运用 $i=\sum_{j=1}^i1$ 的公式，每次 $i\to i+1$ 时把一个后缀和加进答案即可。

$$
f_{i,j,k,l}\to f_{i,j-1,k,l+1}\\
f_{i,j,k,l}+s_{l+1}\to f_{i+1,k+j,j,l}
$$

这样就能做到 $O(N^4)$。

注意到 $i$ 几乎是没用的，我们相当于做以下的操作 $+\infin$ 轮：

- $f_{j,k,l}\to f_{j-1,k,l+1}$
- $f_{j,k,l}+s_{l+1}\to g_{k+j,j,l}$
- 交换 $f,g$

由于是 $+\infin$，又是可以重复贡献的 ckmin，所以我们可以认为他是在进行
- $f_{j,k,l}\to f_{j-1,k,l+1}$
- $f_{j,k,l}+s_{l+1}\to f_{k+j,j,l}$

以任意顺序进行任意多次。

在完全背包中，我们是如何削减状态数的？通过从同一层已经转移的状态转移过来，从而把无穷大卷成了その $1$。

类似地，我们分别以 $l,j,k$ 为第一、二、三关键字的顺序转移，答案就是对的。

### T4

称一个串是合法的，如果对于所有 $a_i=a_j$，$a_{l+r-i}=a_{l+r-j}$。

然后答案就是所有合法串的 $m^{m-c}$ 之和，其中 $c$ 表示串的颜色数。

我会 $O(N^3)$！但是怎么没有部分分

其实很容易就能优化到 $O(N^2)$，然后拿到 20 pts 的高分，但是懒得写了。

赛时想了半天 $|A_i-A_{i+1}|=1$ 的部分分，但其实没有用？？

```c++
for(int i=1;i<=2*n-1;i++){
    for(int i=1;i<=n*2;i++) c[a[i]]=0;
    int cnt=0;
    for(int j=i;j>=1&&2*i-j<=2*n-1;j--){
        if(!a[j]) continue;
        if(!c[a[j]]) c[a[j]]=a[2*i-j],++cnt;
        else if(c[a[j]]!=a[2*i-j]) break;
        if(!c[a[2*i-j]]) c[a[2*i-j]]=a[j],++cnt;
        else if(c[a[2*i-j]]!=a[j]) break;
        (ans+=qpow(m,m-cnt))%=MOD;
    }
}
```

赛时觉得这个做法没什么前途，但其实你可以联想到**回文串**，因为这个东西基本长得跟数回文串贡献差不多一样。

他具有一个类似回文串的性质：对于一个合法子串 $[L,R]$，如果他的子串 $[l,r]$ 是合法的，那么他对应的串 $[L+R-r,L+R-l]$ 也是合法的。证明是简单的。

> 此题实际上是集训队论文《特殊等价关系下的字符串问题》中定义的字符串等价关系的一种

根据这个性质，我们可以做 Manacher！

设目前 $r$ 最大的回文串为 $[l,r]$，中心为 $k$，当前位置为 $i$。

设 $f_i$ 表示以 $i$ 为中心的回文半径，即最长回文串为 $[i-f_i+1,i+f_i-1]$

- 如果 $i+f_{2j-i}-1\le r$，那么 $f_i\gets f_{2j-i}$，然后继续拓展
- 否则，$f_i\gets r-i+1$

但是这个东西怎么继承呢？我们的颜色并非固定，所看重的只有等价关系。

可以维护从左边或者从右边开始碰到第一个没见过的颜色，然后每种颜色维护一个链表。

但是这里 $f_i\gets r-i+1$ 是一个 $f_{2j-i}$ 的历史信息，这里可以用一些可持久化数据结构维护。但是有神秘做法。

我们**直接继承** $2j-i$ 的信息，然后缩至 $r-i+1$，可以证明这个过程是均摊线性的。

（后面没看懂）

## Day6

100+28+0+0=128

### T1

签到题

### T2

赛时先想了一个很假的贪心，增增减减，过不了第 4 个大样例！

然后猜了一个结论：消去重复段和重复出现的形如 `121212` 模式之后，最优答案中间不会出现长度大于等于 7 的空格。

为什么是 7 呢？因为只有调到 7 能通过第 5 个大样例。

然后交上去只拿了 28 分，~~狗操的~~正睿怎么数据这么强啊！

实际上改一点就对了：两次之间不会出现超过 4 种与两个端点不同的颜色。

……等等我的结论貌似差不多**就是对的**，但是由于我没有从 $O(N^3)$ 的 DP 优化到 $O(N^2)$，也就是说没有注意到「只用记最大颜色和次大颜色」的结论，导致没有做出来，草

### T3

考虑把点分为 $<d/2$ 和 $\ge d/2$ 两部分，那么小点之间一定没有边，大点之间一定有边，所以我们只需要考虑小点和大点之间的边，即形如一个二分图。

神秘 trick：按照 $d,0,d-1,1,d-2,\dots$ 排序之后，每个小点与前面所有大点都有连边，且每个大点与前面所有小点都没有连边。因此维护当前染黑的大点数量即可 $O(N^2)$ DP。

……T3 果然大于 T2

### T4

记一个 $|\Sigma|\times |\Sigma|$ 的矩阵 $a_{i,j}$ 表示把颜色 $i$ 改成 $j$ 的数量。

那么 Edit 相当于选择 $x_1,x_2,y$，使 $a_{x_1,y}\gets a_{x_1,y}-1,a_{x_2,y}\gets a_{x_2,y}+1$

ChangeAll 相当于选择 $x_1,x_2$，对所有 $y$，使 $a_{x_2,y}\gets a_{x_2,y}+a_{x_1,y},a_{x_1,y}\gets 0$

我猜想如果 $|\Sigma|=2$，那么只会做一次 ChangeAll，然后我写了

```c++
...
printf("%d\n",std::min(a[0][1]+a[1][0],k+std::min(a[0][0]+a[1][0],a[0][1]+a[1][1])));
...
```

然后得到了零分的好成绩，为什么？？？

显然 Edit 操作一定会在 ChangeAll 后。

我们考虑做了若干次 ChangeAll 后，需要 Edit 的次数。

发现即为 $\sum_{i\ne j}a_{i,j}$。

考虑 ChangeAll 的过程，如果一次选择了 $u,v$，那么就连边一次 $u\to v$。

如果有连边 $u\to v,v\to w$，那么我们一定不会先做 $u\to v$ 再做 $v\to w$，因为不如做 $u\to w,v\to w$。

因此 $u\to v$ 就是 $u$ 最终去到的地方。

显然每个点的出度最多为 $1$，因此形如一个根向基环树森林。

贪心地想的话，怎样连边才是最优的？

显然对于每一行 $x$，我们找到它的最大值 $a_{x,p(x)}$，那么把它移到 $p(x)$ 一定是最优的。

因此我们得到一个基环树森林，我们希望断掉若干条边形成一个新的基环树森林。

一个决策的权值是怎样的？

对于有连边的点，其贡献为 $k+\sum_{i\ne p(x)}a_{x,i}=k+s_x-a_{x,p(x)}$，否则为 $s_x-a_{x,x}$。

直接取 $\min$ 即可。

~~但是这是错的，因为只有 DAG 我们才能按顺序操作。~~

但是你发现，只要他不是纯环，那么就可以操作。

具体的，假设环上一点 $x$ 有树边 $y\to x$，他在环上上一个点是 $z\to x$。

那么我们先操作 $z\to y$，就可以制造一个空位在环上操作，最后 $y\to x$，操作次数也是边数。

所以我们只需要考虑纯环的情况。

我们有三种决策：

- 连一个自环
- 连向一个不是纯环的连通块
- 连向另一个纯环

我们要求第 3 种决策不形成环。

由于至多只有 $|\Sigma|/2$ 个纯环，所以直接状压 DP 即可。

## Day7

100+100+25+0=225

期望：100+100+25+50=275

[REDACTED]的 T4 怎么直接就改题面了我还不知道我还以为改的只是

> 更新了 T4 的样例解释。

我[REDACTED] 50 pts 全没了啊！！！我[REDACTED]的 50 pts 全没了啊！！！:rage::rage::rage::sweat_smile::sweat_smile::sweat_smile:

赛前加强一下这一块，赛前加强一下还不告诉我这一块

### T1

签到题

### T2

瞪一下，发现形如 Ferrers 图，然后就 A 掉了

### T3

首先你发现题目给出的图形如一个二维偏序，可以定向为 DAG。

这种图被称为<ruby>可比性图<rt>Comparability Graph</rt></ruby>或偏序图。

我们可以证明其为<ruby>完美图<rt>Perfect Graph</rt></ruby>，即其任意导出子图都满足 $\chi(G)=\omega(G)$，即色数等于最大团的大小。

所以就是要求最大团 $\le 3$，即最长链 $\le 3$，即 LDS $\le 3$。

我的 AI 告诉我这道题可以用一些深刻的杨表结论表示。

其实是神秘的 DP。

没想到可以用那个经典的 lower bound 求 LIS 的算法，其实我此前一直不会这个算法。

这里换到求 LDS，就是维护一个递减序列，每次加入一个元素 $x$，就找到序列中第一个 $\le x$ 的位置覆盖掉，如果全部 $>x$ 就插入到末尾，最终序列即为 LDS。

从前往后加入每个数。设 $f_{i,j,k}$ 表示若当前维护的递减序列为 $(x,y,z)$，则还没有加入的数中，$(x,n]$ 有 $i$ 个，$(y,x)$ 有 $j$ 个，$(z,y)$ 有 $k$ 个，这样的长度为 $n-i-j-k$ 的前缀有多少个。

则可以转移到 $f_{u,i-u-1+j,k},u\in [0,i)$，$f_{i,v,j-v-1+k},v\in[0,j)$ 和 $f_{i,j,k-1}$。

可以前缀和优化到 $O(N^3)$。

对于字典序的限制，相当于钦定一个前缀，跟我们的 DP 是适配的。

### T4

赛时主要想着对 $a$ 搞笛卡尔树，怎么我最近好几道不是笛卡尔树的题都一直在想做笛卡尔树结果不会了呢？

后面想了想能不能扫描线做，发现形如在平面上放若干个平行四边形，好像做不了，最后写了暴力跑路。

upd: 其实是可以做的，只要把坐标系映射一下就变成了矩形加。然后变成区间加查询每个位置的绝对值历史 min。貌似做不了。

强化之后也是可以做的，但是要用猫树分治，区间加区间查询绝对值历史 min。貌似做不了。

但是题目在正式开赛前强化了一下，原题变成了性质 A，导致我一分没拿到，[REDACTED]。

其实可以 CDQ 分治。

设 $[L,R]$ 表示当前分治区间，中点为 $m$，考虑 $l\in[L,m],r\in(m,R]$ 的区间的贡献。

显然我们只在乎 $[L,m]$ 的 $a$ 和 $b$ 的后缀最小值，和 $(m,R]$ 的 $a$ 和 $b$ 的前缀最小值，分别记为 $la,lb,ra,rb$。

则区间 $[l,r]$ 的值即为 $|\min(la_l,ra_r)-\min(lb_l,rb_r)|$。

枚举 $l$，大分讨拆掉两个 $\min$，则合法的 $r$ 形如一段区间，相当于做区间 ckmin。因为是离线的，可以维护一个优先队列的差分，时间复杂度 $O(n\log^2 n)$，空间复杂度 $O(n\log n)$。

加强之后怎么做？考虑用类似线段树分治的做法，把询问分散到几个整区间内。

对每个整区间，都可以跑一遍优先队列前缀和。

但是可能会有跨区间的贡献。怎么办呢？考虑猫树分治。

考虑以 $k$ 为横坐标，$l$ 为纵坐标。

那么每次放的东西相当于在一条横线上 ckmin，然后每次询问相当于求一条纵线上的 min。

注意到横线之间甚至没有重叠，所以连优先队列前缀和都没有必要，用一个线段树辅助维护一下区间 min 即可。

~~然后就做完了。~~

我傻掉了，写的时候才发现、权值可能跟 $r$ 相关。

所以这个不是简单的 ckmin，是整个数组在各种意义下的位移之后 ckmin。那这个跟我一开始那个平行四边形有什么区别？？？

考虑对于一个 $k$，当 $l$ 移动时，答案的变化。

由于我们答案是分四类情况：

- 对于 $ra_r<la_l,rb_r<lb_l$，贡献 $|ra_r-rb_r|$ 仅与 $r$ 相关。所以只要预处理这个东西然后做一遍区间 min 即可。由于当 $l$ 向左移动时，$r$ 的左边界也向右移动，所以合法的位置一定形如一段区间。
- 对于 $ra_r>la_l,rb_r<lb_l$，贡献 $|la_l-rb_r|$。注意到当 $l$ 左移动时，$la_l$ 变小，$rb_r$ 变大，所以这个函数一定是单谷的，可以三分出来。然后求最接近这个谷的合法的 $r=l+k-1$ 即可。可以发现当 $l$ 向左移动时，$r$ 的左边界向右移动，右边界向左移动，也就是越来越不合法，所以合法的 $l$ 形如一段后缀。
- 对于 $ra_r<la_l,rb_r>lb_l$，类似第 2 种
- 对于 $ra_r>la_l,rb_r>lb_l$，贡献 $|la_l-lb_l|$ 仅与 $l$ 相关，所以只要看是否存在合法的 $r$ 即可。注意到对于一个 $k$，合法的 $l$ 必然形如一个前缀，取 min 即可。

这 94 大<ruby>分<rt>粪</rt></ruby>讨啊（喜

这里还有一个 $[L,R]$ 的限制，可以发现依然形如区间 min 的形式。

## Day8

我操我怎么挂完了

20+20+0+0=40...

何意味

怎么样例水得跟:shit:一样

### T1

赛时首先发现了一个必要条件：对于 1 链中任意三个连续的点，必然也在 2 链中连续。

然后我大胆猜想除了 $n\le 3$ 的情况，那么只有顺序和逆序两种情况是合法的。

但是是错的，充要条件是 $\forall i,|q_i-q_{i+1}|\le 2$。

他就不能多给几个样例吗……

### T2

正向考虑很难做，但是你发现除了 $a=b$ 的情况，那么只能做一种逆操作，形如辗转相减，可以辗转相除优化到 $\log V$，然后时间复杂度 $O(n\log n\log V)$，空间复杂度 $O(n\log V)$，这是怎么存得下的？这是怎么跑得过的？

出题人给的 `2000ms 512MB` 是他心胸的大小吗？开大一点会[REDACTED]吗？

而且出题人的样例是[REDACTED]故意造这么水的吗，怎么五个大样例都过了交上去第一个点就 WA 了？

upd: 拍了几千组没拍出来错误，不做了

### T3

考虑把他看成一个匹配问题：对于两棵树的非根节点，我们都需要匹配一条父边，然后就是对的。

现在边有两色，对于左部点，每种颜色的边匹配恰好一条，对于右部点，他只有两条连边，且从中选恰一条。

其实左部点的两种连边相独立，所以可以拆成两个点，所以现在左、右部都有 $2n-2$ 个点。

注意到由于右部点度数为 $2$，所以不妨「缩二度点」，直接给左部的两个点连边。

然后匹配哪个点可以看作给边定向，也就是要求每个点的出度为 $1$。特别的，如果是自环直接非法。

不难发现只有连边形如基环树时是合法的，且每个连通块有两种可能。

### T4

拼尽全力想出 $O(n\sqrt n\log n)$ 做法，结果假掉了。

不会离线做法导致的。

> 由于这太简单了

但是根本没想到。

考虑**倒过来**操作，然后就是区间 ckmin。

这启发我们维护**没出现过的数**。

考虑对于一个数 $x$，它的插入形如若干段区间覆盖。

那么对于每个 $x$，对于它的**没有被插入的区间**，我们在这些地方做 ckmin，然后维护区间 max。

但是每次插入 $x$，相当于撤销一段 ckmin 操作，怎么做？

考虑在每个线段树节点上挂一个可删堆，维护所有的整段 ckmin 标记，运用标记永久化的思想。然后就做完了……

## Day9

*ALL KILL!*

## Day10

期望：100+0+82+0=182

实际：100+0+48+0=148

### T1

打表找规律无果

考虑贪心倒着选一定是最优的。

赛时的思路是按照 $[2^{k-1},2^k-1]$ 分段，分别处理，应该也能做，但是麻烦。

考虑找到最小的 $2^k>r$，即 $r$ 所在段，则 $[2^k-r,r]$ 每个数选与不选是确定的，且与前面互不影响。

所以可以递归转移到 $[l,2^k-r-1]$。

### [T2](https://atcoder.jp/contests/yahoo-procon2018-qual/tasks/yahoo_procon2018_qual_d?lang=ja)

容易转化到 $Y=0$ 的情况。

考虑设 $x_{i,j}$ 表示 $(i,j)$ 是否异或上 $X$，那么我们计算 $A_{i,j}\oplus A_{i,j+1}\oplus A_{i+1,j}\oplus A_{i+1,j+1}$，查看等于 $0$ 还是 $X$，即得到 $x_{i,j}\oplus x_{i,j+1}\oplus x_{i+1,j}\oplus x_{i+1,j+1}$。

~~不难发现形如 4-SAT 问题，只要我们证明 P=NP 即可解决此题~~

---

完全没想到题解思路，赛时主要想着在行和列之间差分，没有想到在行内操作。

注意到 $A_{1,i}\oplus A_{1,j}=A_{i,j}(\oplus X)$，因此只要确定 $x_{1,i}$ 的值即可确定整个 $x$。

枚举 $a_1$，则 $A_{1,i}=a_1\oplus a_i(\oplus X)$，即 $a_i=a_1\oplus A_{1,i}(\oplus X)$，有两种选择。

注意现在各个 $a_i$ 基本是独立的，我们只要满足 $b$ 的限制即可。

先别急着上多项式，注意到 $\oplus X$ 是一个一对一映射，这意味着我们可以把整个值域一一配对，每对之间互相独立。

记 $t_x,x<x\oplus X$ 表示 $a_1\oplus A_{1,i}=x$ 的 $i$ 的数量，则贡献为 $\sum_{i=0}^{t_x}[t_x-i\le c_{x\oplus X}]\binom{t_x}{i}$，是一个二项式系数行内部分和的形式。

其中 $c_i$ 表示 $i$ 在 $b$ 中的出现次数。

直接枚举即做到 $O(n^2)$。

### T3

考虑递推式 $h_i=h_{i-1}-h_{i-2}$，将其表示为 $h_1$ 和 $h_2$ 的线性表示，手玩一下发现循环节为 $6$。

考虑 $x=h_1,y=h_2$，然后发现一个 $h_i$ 对答案 $(x,y)$ 的贡献，形如到一条直线的距离。

然后你发现若干条这样的东西加起来，答案肯定是凸的。

由于只有 $6$ 种斜率，对每种斜率，算出来夹在哪两条直线之间即可，三分套三分之后可以用树状数组维护。时间复杂度是 $O(q\log^3 V)$。

然而赛时由于三分没有处理负数的向下取整，而且有一个地方忘开 long long，导致 82 挂成 48。

为什么隔壁大佬同样的算法跑了 90 分……

---

实际上只有 $3$ 种贡献，另外 $3$ 种只要取个相反数即可。

如何规避三分？

通过简单的变换，可以把代价写作 $f_0(x)+f_1(y)+f_2(x+y)=\min_{z=x+y}f_2(z)+f_0(x)+f_1(y)$。

所以我们算出 $f_0$ 和 $f_1$ 的 min-plus 卷积即可。

每次修改需要把 $f_0,f_1$ 和 $f_2$ 加上一个绝对值函数，好像做不了。

记 $F(z)=\min_{z=x+y}f_2(z)+f_0(x)+f_1(y)$，显然 $F$ 是一个凸函数，我们只想求出它的谷。

如果三分其位置，那么每次需要求出 $G(z)=\min_{z=x+y}f_0(x)+f_1(y)$ 的值，比较难做。

我们不妨二分其位置对应的 $G(z)$ 的斜率，这样单点求值只需要求出 $f_0(x)$ 和 $f_1(x)$ 的斜率 $\le$ 它的边的向量和。同时一次性求出了横纵坐标。

这样可以做到两只 log

实际上三分并不好写，我们不妨二分求出 $F'(z)$ 的导数 $\le 0$ 的最大位置。

题解做法为什么是根号的？\bx <span style=color:red>S</span><span style=color:black>iyuan</span>

### T4

设 $f_{t,i}$ 表示跳了 $t$ 步之后位于点 $i$ 的方案数。

然后不会做了。

乾原来是看错题了，赛时以为题图形如一个高度为 $n$ 的满二叉树，其中根的高度为 $1$。

但是实际上是有 **取模** 的，所以 $\times 2\bmod N$ 就是循环移位，$\times 2+1\bmod N$ 是在循环移位的基础上再加 $1$。

如果连续操作 $n$ 次，会产生 $2^n$ 种可能，再总共的 $2^n-1$ 个节点中，只有它本身是本质不同的，所以可以猜测转移到它本身的方案数为 $2$；否则为 $1$。

暴力跳 $c\bmod n$ 步之后，需要乘上形如
$$
A=\begin{bmatrix}
    2&1&1&\cdots&1\\
    1&2&1&\cdots&1\\
    \vdots&\vdots&\vdots&\ddots&\vdots\\
    1&1&1&\dots&2\\
\end{bmatrix}^{\lfloor c/n\rfloor}
$$

的矩阵。

考虑组合意义，枚举乘了多少个 $2$，即得到
$$
A_{s,t}=\sum_{i=0}^{\lfloor c/n\rfloor-1}\binom{\lfloor c/n\rfloor}{i}2^iN^{\lfloor c/n\rfloor-i-1}=\frac{1}{N}((2+N)^{\lfloor c/n\rfloor}-2^{\lfloor c/n\rfloor})\\
$$

特别的，对于 $A_{s,s}$ 还要加上 $2^{\lfloor c/n\rfloor}$。

可以发现其实系数基本上是完全一样的。

现在考虑 $[l,r]$ 的贡献。

考虑拆贡献变成：枚举 $[l,r]$ 中每个 $i$ 和经过它的时间 $j$，计算从 $s$ 在 $j$ 步内走到 $i$ 的方案数乘上 $i$ 在 $c-j$ 步内走到 $t$ 的方案数。

为了适配我们的 $O(Nn)$ 的 DP，考虑先计算 $s$ 走 $j$ 步的 DP 数组，然后只保留 $[l,r]$ 的值，然后再走完剩下 $c-j$ 步。

由于后 $c-c\bmod n$ 步的贡献几乎是相同的，我们不妨合并为一项。

所以我们只用在每个 $j\bmod n$ 处把贡献在中间计算一下即可。

## Day11

100+15+100+0=215

### T1

宝宝题

### T2

操了这么唐的题怎么没想到，场上就差最后一步就做出来了。

记两个相邻点 $(x,y),(z,w)$ 的边权等于 $[a_{x,y}\ne a_{z,w}]$

场上转化为选择一条路径，使得路径上的边权和加上没有被选的点的颜色数最少。

然后我转化为选择若干段区间 $\{[l_i,r_i]\}$ 使得 $r_i+1<l_{i+1}$，上下两行交错选择，使得被选的总颜色数加上没有被选的边权和最少。然后我不会做这个，只写了 15 分特殊性质跑路。

但其实我转化错了：如果没有选的点的颜色出现路径上，且更靠后，其实我们是可以把它选掉的。

所以只需要看一下每个颜色最后出现的位置是否不在路径上即可。

### T3

注意到合法当且仅当 $\forall i\in S,a_i\nmid \operatorname{lcm}_{j\in S,j\ne i}a_j$

显然其满足区间包含单调性。所以双指针维护即可。

场上调了 3h，[REDACTED]

### T4

神秘题。

这种大概只能拆贡献，考虑枚举 $|i-j|$ 看他算了多少次。

由于 $x$ 相同的点是本质相同的，所以状态数比较少。

实际上我们只关心 $\sum_k [x_k=x_i],[q=i],[x_i=x_j]$，这三个值总共只有 $4n$ 种可能性。

不需要记 $[q=j]$ 是因为是对称的。

设这三个变量分别是 $a,b,c$，答案为 $f(a,b,c)$。

能否转移？显然终态即为 $f(n,0/1,1)$ 或 $f(0,0/1,1)$，其等于 $0$。

一次操作之后，会把 $x_j$ 的颜色翻转，并等概率随机选取一个 $k$ 进行转移，分四类：

- $k=j$
- $x_k=x_i$
- $k=i$
- $x_k\ne x_i$

讨论即可。

因此转移形如：

$$
\begin{aligned}
f(a, 0, 0)&= \frac{1}{n} f(n - a + 1, 1, 1) + \frac{a - 1}{n} f(a - 1, 0, 0)\\ &+ \frac{1}{n} f(a + 1, 0, 1) + [a < n] \frac{n - a - 1}{n} f(a + 1, 0, 0)\\
f(a, 1, 0)&= \frac{1}{n} f(n - a + 1, 1, 1) + \frac{a - 1}{n} f(a - 1, 0, 0)\\ &+ \frac{1}{n} (f(a + 1, 0, 1) + 1) + [a < n] \frac{n - a - 1}{n} f(a + 1, 0, 0)\\
f(a, 0, 1) &= \frac{1}{n} f(n - a + 1, 1, 0) + \frac{1}{n} f(a - 1, 0, 0)\\ &+ [a > 1]\frac{a - 2}{n} f(a - 1, 0, 1) + \frac{n - a}{n} f(a + 1, 0, 1)\\
f(a, 1, 1) &= \frac{1}{n} f(n - a + 1, 1, 0) + \frac{1}{n} (f(a - 1, 0, 0) + 1)\\ &+ [a > 1]\frac{a - 2}{n} f(a - 1, 0, 1) + \frac{n - a}{n} f(a + 1, 0, 1)\\
\end{aligned}
$$

然后可以注意到 $f(a,1,c)=f(a,0,c)+\frac 1 n$，所以可以变成 $2n$ 个变量。

$$
\begin{aligned}
f(a, 0)&= \frac{1}{n} f(n - a + 1, 1) + \frac{a - 1}{n} f(a - 1, 0)\\ &+ \frac{1}{n} f(a + 1, 1) + \frac{n - a - 1}{n} f(a + 1, 0) + \frac{1}{n ^ 2}\\
f(a, 1) &= \frac{1}{n} f(n - a + 1, 0) + \frac{1}{n} f(a - 1, 0)\\ &+ \frac{a - 2}{n} f(a - 1, 1) + \frac{n - a}{n} f(a + 1, 1) + \frac{1}{n ^ 2}\\
\end{aligned}
$$

进一步的可以注意到，事实上 $1<a<n$ 时 $f(a,0)=f(a,1)$，进一步的可以缩减到 $n$ 个变量。

$$
f_a = \frac{1}{n} f_{n - a + 1} + \frac{a - 1}{n} f_{a-1} +\frac{n - a }{n} f_{a + 1} + \frac{1}{n^2}
$$

设 $f_1=X,f_{n-1}=Y$，则可以递推一遍把所有变量表示成 $AX+BY+C$ 的形式，然后直接解出来，时间复杂度 $O(n)$。

最后每次修改和询问是简单的，时间 $O(n+q)$。

## Day12

气死我了，掉大分

怎么我几乎四道题都会但是全挂完了

### T1

其实赛时已经*几乎*想出了正解，但是由于没有建 Trie，而且证明不了充要，所以没有写。

说白了 T1 放这种贪心构造题的出题人就是[REDACTED]吧！

### T2

妈的我一开始看到 PA90 发现挂掉两个点面向数据编程了一下结果没过编译变成 CE0 了

我真的[REDACTED]了，出题人你[REDACTED]了。

### T3

这道题真的做过的。

考虑 $k$ 比较小，可以状压 DP。

否则，考虑按照 $1,k+1,2k+1,\dots,2,k+2,2k+2,\dots$ 的顺序加入，那么只用记一下每一段放的 $1$ 的个数即可。

### T4

妈的 NOIP 放个傻逼平衡树题出题人真的死妈了。

调了 INF 年没调出来交上去只有 32 分不如暴力。

## Day13

何意味？

应得：100+100+100+50

实得：16+100+0+10

第一次看到题目放了看过的漫画

怎么每次都是几乎都会做但是挂大分呢？

### T1

改题绷不住了

改之后合法当且仅当所有质数的数量是偶数，改之前还得判一下是否有绝对众数。

然后按改之后写 16 分，按改之前写 40 分:thumbsup:，而且两者都能过大样例:thumbsup:

大样例强度与 CCF 一模一样:thumbsup:

没有注意到 $n$ 是奇数则一定合法，然后挂完了

### T2

考虑 $x_i$ 和 $y_i$ 连边，那么变成一个要求某个点的度数的奇偶性的二分图匹配。

这个其实比正常的二分图匹配弱很多，放到一般图上也能做，只要让每个连通块内的要求加起来是偶数即可。

### T3

我们称一个颜色「被选」，如果我们对其全部执行了「搬到后面」的操作。

考虑每种颜色，发现除了它是最后一段颜色，否则它要么要求夹在中间的颜色全部被选，要么它本身被选。

特别的，对于最后一段颜色，我们允许其要么夹在中间的颜色全部被选，要么把除了最后一段以外的其他部分搬走，我们可以看作其搬走的代价要减去最后一段。

除此之外，如果最后一段的颜色被选，且一个后缀的元素皆被选，则这个后缀内的最后一段颜色都不需要搬。

实际上最后一个颜色没那么特殊，因为我们可以把一个元素调到后尾然后取代他。

因此整个后缀可以删掉任何一种元素。

线段树辅助连边之后，你发现这个东西形如最小权闭合子图，但是我想这个东西不是 $O(n\sqrt{n})$ 的吗就没写。

---

找到第一个位置和最后一个位置，我们发现两个东西能都不选，当且仅当不交。

然后可以转化为「$m$ 个区间，从中选出两两不交的若干个使价值之和最大」这种经典的问题。

然后 DP 即可。

### T4

对于 $k>B$，跑猫树分治，时间复杂度 $O(qV/B\log n)$，或者可以莫队，时间复杂度是 $O(n\sqrt n+qV/B)$。

对于 $k\le B$，提取出所有 $k|a_i$ 的位置，则所有数组的长度之和为 $O(n\log V)$，但是我不会这个。

所以最后写了一个莫队骗分，但是前面全部 WA 掉了。因为为了赶时间就没测大样例，结果其实是我看错题了，如果一个数字实际上没在 $a[l,r]$ 出现但是确实是 $[x,y]$ 中的 $k$ 的倍数，那么我们也要把它计入答案。

实际上要是赛时看到了正确的题面就很简单了，$k\le B$ 的情况相当于 $O(\sqrt n)$ 做单点 $+1/-1$，然后 $O(1)$ 求区间 min，分块之后每个块开一个桶维护 cnt 即可。

块长取 700 过了，目前最速解。

## Day14

应得：100+100+100+50.61

实得：100+100+100+0

### T1

签到想半天。:sweat:

考虑 $i$ 最终到了 $p_i$，那么 $a_i$ 会变成 $a_i+i-p_i$。

因此按照 $a_i+i$ 排序即可

### T2

注意到可以枚举分界点，然后求出形如「左边修改 $k$ 次的最长 $0$ 连续段」和「右边修改 $k$ 次的最长 $1$ 连续段」的 max-plus 卷积即可。

虽然不是凹的，但是允许我们暴力算。

然后我们可以求出所有有用的数对 $(x,y)$ 表示允许同时出现的最长 $0$ 连续段和右边修改 $k$ 次的最长 $1$ 连续段，对每个 $a$ 暴力算一遍即可。

### T3

场上尝试找规律没找出来。

一开始打表推出了 $a_i\le 2$ 的规律，然后想要类推到 $a_i\le 3$，但是没成功；

然后打表推出了 $a_i\le 3$ 的规律，极为复杂，可能是我表打错了。

其实结论就是，后手必胜当且仅当存在一个子集和等于总和的一半。

因为后手必胜当且仅当能够全部消完，而我们的操作相当于选择一个子集 $S$ 的和等于 $U\backslash S$。

如果存在这样的集合，那么无论先手怎么选后手都能控制，只要每次都选当前「状态」与这个元素相反的元素即可。

所以可以直接用 bitset 解决，时间复杂度 $O(N^4/w)$。

### T4

弱化版：CF1292E。

不是我怎么 ILE 了不是我怎么 ILE 了不是我怎么 ILE 了。

Pretest 过了 50.61 分，方法是先随机出一个串在 $S$ 中出现至少一次。

不妨令 $k\gets k+1$

随机长度为 $m$ 的串的期望时间是 $m^k/k^2$ 再做个生日悖论，$m=2/\ln(k)$ 时最优，应该会比较少。

随出来之后我们可以每次拓展，需要的代价大约为 $\sum_{n}k/n^2=O(k)$。

正解是构造。

#### $k=2$

赛时想到问 `01` 和 `10`，但是无法分别 `111...111` 和 `000...000`。

考虑询问 `01`，`100`，`101`。

则无法分别 `000...000`，`111...111`，`111...110`。

我们再问一次 `111...11`（$n-1$ 个 $1$）即可，这样可以通过 $n\ge 7$ 的数据。

然后 考 虑 手 模，只用考虑 $n=4,5,6$ 即可。

或者可以爆搜分组得到最优解。

#### $k=3$

考虑询问 $00,01,02,11,21$，则能够确定 $S_{2\sim n-1}$，且只剩 4 种情况，能够通过 $n>4$ 的数据。

对于 $n=4$，可以爆搜分组。

#### $k=4$

## Day15

应得 100+100+?+0

实得 100+100+0+0

### T1

签到题瞪半天。

一开始看错题了，以为是写成 `sshwy` 的循环同构串，测样例才知道不是。

然后哈希即可。

如果这里写 `std::unordered_map` 本地会跑得特别慢，所以手写了一个哈希表。

一开始选了一个 $10^{13}+7$ 的模数，但是大样例会哈希碰撞；改成 $10^{13}+9$ 也会碰撞。

一开始写了一个三哈希，成功拿到 <span style="color: yellow;">TLE90</span>。

双哈希也是 <span style="color: yellow;">TLE90</span>。

改成一个 $10^{18}+3$ 的模数（用 __int128 做乘法）就 <span style="color: green;">AC</span> 了，神秘概率。

可能是因为我之前用的模数不是质数的缘故。

### T2

设 $f_{n,m,x}$ 表示第一行有 $n$ 个，第二行有 $m$ 个点，我们从第一行的 $x$ 开始的路径数。

则有转移

$$
f_{n,m,x}=1+\sum_{i=1}^{x-1}f_{n-(x-i),m,i}+\sum_{i=x+1}^nf_{n-(i-x),m,x}+g_{m,n-1}\\
g_{n,m}=\sum_{x=1}^nf_{n,m,x}
$$

所求即为 $g_{n,m}+g_{m,n}$。

上式直接做是 $O(N^4)$，不难简单前缀和做到 $O(N^3)$，要想达到 $O(N^2)$ 尚需推式子。

$$
\begin{aligned}
g_{n,m}&=\sum_{x=1}^nf_{n,m,x}\\
&=n+2\sum_{x=1}^n\sum_{i=1}^{x-1}f_{n-(x-i),m,i}+ng_{m,n-1}\\
&=n+2\sum_{j=1}^{n-1}g_{j,m}+ng_{m,n-1}
\end{aligned}
$$

然后一个前缀和即能做到 $O(N^2)$，每次查询是 $O(1)$ 的，不清楚它的 $T$ 设这么小是干什么。

### T3

注意到 LIS 与 LDS 必然共用恰好一个点。

然后就<ruby>没思路了<rt>跑去写T4了</rt></ruby>

由于左右两边必然对称，所以这个点一定就是序列的中点

考虑暴力枚举这个点的值 $k$，如果我们已经确定了 $k$，那么我们就知道了已确定的数中什么属于 LIS，什么属于 LDS。

考虑从左到右扫一遍，不妨假设当前确定的数字 $a_i$ 属于 LDS，上一个确定的、属于 LDS 的数为 $a_j$，那么我们要将 $(a_i,a_j)$ 的数放入 $(j,i)$ 中。

设上一个确定的属于 LIS 的数字为 $a_k$，若 $k\in(j,i)$，那么放完 $(a_i,a_j)$ 后必须保证 $k$ 之前没有任何空位。

空位数 $b=k-(a_k+(n-a_j+1))$，因此方案数为 $\dbinom{i-k+1}{a_j-a_i-1-b}$。

### T4

~~[REDACTED]一开始看错题了，以为不同位置的相同串也计算。~~

~~不妨容斥，考虑计算~~

~~- 所有不包含回文子串的子串的个数~~
~~- 所有能够通过翻转一个子串变成回文子串且不包含回文子串的子串的个数。~~

~~第一个容易计算，不需要马拉车，直接找到所有形如 `aa` 或者 `aba` 的位置，然后对于每个 $l$ 找到最大的满足的 $r$ 即可。~~

~~对于第二个，可以发现相当于找到 $(i,j)$ 使 $i+LCP(i,j)+1\ge j$，有两种本质相同的思路，可以用 SA+启发式分裂 或者 DSU on SAM 维护，我赛时写了前者……~~

~~其实如果写了后者，很容易改成要求本质不同的情况。~~

~~其实并没有困难多少。~~

~~对于第一类，可以如上预处理，对于每个 SAM 节点，可以找到其最长的合法串，<ruby>取第一个<rt>随便取一个</rt></ruby> $r$ 即可。~~

~~对于第二类，不妨改写为 $i+LCS(i,j)+1\ge j$，对于所有这样的 $(i,j)$ 求出使 $[i-(j-i)+2,j]$ 合法的区间的数量，如果 $i+LCS(i,j)\ge j$，还需要带上 $[i-(j-i)+1,j]$。~~

~~在反串后缀树上，LCS 等价于 LCA。~~

万分抱歉，我赛时想错了。

赛时以为只要 $i+LCP(i,j)+1=j$ 或者 $i+LCP(i,j)=j$ 即可，但其实情况复杂得多。

其实这是一个大分讨题，赛时还信誓旦旦的说这个 DS 硬做就行来着

首先我们不妨对于每个 `aa` 和 `aba` 的位置断开一下，然后对每段区间分别计数即可去掉限制 1。

考虑限制 2 的非法串，一定可以表示为 $B^RAAB,B^RAcAB,B^RcAAB,B^RAAcB$，其中第 3 种需翻转 $cA$，第四种类似。

考虑会不会算重，首先对于一个 $T$，我们去除掉外面的极长回文前后缀，即 $B^R$ 和 $B$。

首先第一类与其他长度的奇偶性就不同了，可以先去掉。

同时可以发现 $A$ 的长度是确定的，因此如果出现 $Ac=cA$，之类，可以发现 $A$ 全都是 $c$，于是出现回文子串，矛盾。

因此不会算重，可以对 4 种分别计算。

但是上面的论证是错的。因为我们去掉极长回文前后缀的时候可能把中间的部分也去掉了。

首先这种情况不可能出现在 $B^RAAB$ 和 $B^RAcAB$，因为会在中间也形成一个回文子串。

因此这种情况一定可以写成 $B^RcDcDcB$，会产生 $3$ 个贡献，我们*要求*在 $B^RAcAB$ 的地方贡献。

统计 $B^RAAB$ 可以用一个经典但是我没见过的调和级数 trick，就是枚举 $|A|$，然后每隔 $|A|$ 个位置打一个标记，然后计算相邻两个标记的 LCP 和 LCS，即可知道 $A$ 的可取范围。

但是我们还得求 $B$ 的范围，注意到如果有相邻的多种 $A$ 可取，那么如果存在 $|B|\ne \varnothing$ 就会出现两个相邻相同字符，因此此时 $|B|= 0$

对于 $B^RAcAB$，可以发现如果有相邻的两个 $A$，则 $|B|\le 1$，或者只有一个地方 $|B|\ne 0$，否则会出现回文串。

我靠了这也太复杂了太难讨论了不写了

这种情况两个串是错开的，所以把当前的距离当成 $|A|+1$ 即可。

但是这种情况可能刚好没有碰到我们的标记，此时我们的标记充当 $c$，特殊处理一下即可。

对于 $B^RcAAB$，可以发现如果有相邻的两个 $A$，则构成 $B^RcDcDcB$，如果有三个，则形成回文子串，此时 $|B|=0$，因此多讨论一下即可。$B^RAAcB$ 类似。

## Day16

### T1

首先可以转成区间操作

首先 $<k$ 的元素不会动，所以不用管，可以当成删掉了，因此此题把区间 ckmin 换成区间覆盖不会更简单。

可持久化线段树维护区间内 $k$ 的个数，暴力进去修改，但是这样均摊复杂度是错的，因为有时间回溯操作。

考虑建出一棵版本树，则一个元素一定在若干棵子树内变成 $k$，也就是区间第一次覆盖到它的位置。

考虑每个区间覆盖，发现相当于做一个矩形覆盖，也即在版本树上的子树和原树上的子树，然后我们扫描线维护即可。

其实不用那么麻烦，注意到我们修改一定是修改一段前缀和一段后缀。

所以每次找到第一个和最后一个没被 ckmin 的位置即可。

### T2

二分答案即可

### T3

可以发现形如最小链覆盖，然后跑一个拓扑排序即可

### T4

做过的，但是忘了。赛时放了一个 FWT 上去骗分。

不妨容斥为 $l=0$ 的情况。

考虑每个 $a_i$ 能选什么？发现一定是顶住一段前缀，然后后面任选的情况。

我们这样把所有情况归类，发现我们只要找到任选段的最大值，且前面都是合法的（异或和为零），那么答案等于 $2^{\sum-\max}$，这里 $\sum$ 和 $\max$ 都表示任选段的长度。

这启发我们只要枚举一下这个最大值，判断一下前面是否合法，然后就能计算答案了。

计算时，我们找到这一位 $r_i=1$ 的位置，它们可以成为最大值。

如果固定为最大值，则 $i$ 的贡献为 $2^l$，否则为 $r_i\bmod 2^l$。

但是直接容斥时间复杂度就 $O(2^n)$ 了，所以可以 meet in the middle

左右两边的前面部分都有 $\log$ 个，讨论 $\max$ 在哪边即可。

## Day17

闭上眼睛想一下:smile:

怎么都是小清新性质题。

### T1

貌似小时候做过类似的题。

注意到在 $x$ 和 $x+1$ 之间划一条横线相当于交换 $x$ 和 $x+1$ 的位置。

所以答案就是逆排列的逆序对个数。

所以为什么数据范围不调到 $n\le 5\times 10^5$ 呢？

### T2

别笑你也过不了第二关

草怎么一车人过了

我会树上背包！考虑设 $f_{i,j}$ 表示 $i$ 子树内有 $j$ 个点未被匹配，的方案数。

转移即为树上背包，时间复杂度 $O(n^2)$。

赛时饭堂了，以为树上背包要用 NTT 优化，其实不用，直接做就是 $O(N^2)$ 的，考虑 LCA 个数。

但是不会求交点个数。

**这题的关键在于，对每一个交点，需要找到一个合适的把它计入答案的时机。**

设 $g_{i,j}$ 表示这样的所有方案的交点个数之和。

我们可以考虑在 $i$ 的子树内，就钦定好未被匹配的结点匹配的结点的顺序，贡献提前计算。

### T3

[POJC24E](http://poj.openjudge.cn/practice/C24E)

模拟费用流，但是没调出来，最后交了一个费用流的上去骗分。

考虑增量算法，什么样的增广路是好的。

由于我们只需要考虑长度 $>0$ 的路，所以只需要考虑三种增广路

- 把一个 $0$ 档的学生调到 $1$ 档
- 把一个 $0$ 档的学生调到 $2$ 档
- 把一个 $0$ 档的学生调到 $2$ 档，同时把前面一个学生的档数减少 $1$

其实这种题多观察几眼就能发现更多性质。

其实用一个 优先队列 就能维护出来所有的增广路，而且从右往左增量更简单。

### T4

赛时尝试刻画一个 $O(n^2)$ 判断的充要条件，失败。

实际上可以发现充要条件是

- 对于每个 $x$，所有 $\ge x$ 的位置构成一个区间，不妨记作 $R_x$。

然后只要确定了峰值所在位置之后，对于每个左边的 $i$，我们只要判断 $[i,i+(n-a_i+1)-1]$ 中是否有 $<a_i$ 的元素即可；右边类似。

实际上我们可以等价地考虑对于所有 $i>j$ 有 $R_i\subsetneq R_j$，这样我们只需要比较前驱后继是否有包含关系即可。

我们可以用一个 set 维护前驱后继关系。

只用枚举考虑峰值在最大值的左边还是右边即可，这只会影响最大值的区间。

## Day18

### T1

注意到每个斜对角线的元素不发生变化，所以只要每个斜对角线上元素是重排即可。

怎么连续两天的 T1 都存在超越数据范围的做法？

### T2

区间 DP 即可。

笑点解析：我一开始想了一个贪心做法。

### T3

虽然知道是 $O(2^{n/2}\operatorname{poly}(n,m))$ 级别的，但是不会。

赛时写了一个 $O(m2^{\# ?})$ 的做法。

赛时考虑过容斥，但是没想到可以把容斥融入到 DP 中。

果然还是每次都总想着直接全局做，实际上分解成 DP 会更简单。

已经观察到的性质：

- 求交是容易的，求并是困难的。
- 集合求差的数量级取决于被减数是问号且减数不是问号的维度数量。

考虑倒着做，每次计算 $s$ 影响的下标个数，然后删除这些下标。

记 $f(S,i)$ 表示 $S$ 集合中的下标，其中 $S\subseteq \{0,1,2,\dots,2^n-1\}$，在进行前 $i$ 次操作后，的和是多少。

所求即为 $f(\{0,1,2,\dots,2^n-1\},m)$。

则有转移 $f(S,i)=f(S,i-1)-f(s_i\cap S,i-1)+|S\cap s_i|\cdot v_i$

然后你发现这里的 $S$ 一定是若干个 $s_i$ 的交集，因此是一个简单的整区间，可以由 `0 1 ?` 表示。

如果 $\dim(s_i\cap S)\le \dim(S)-2$，则直接暴力搜索就是对的。

否则如果 $\dim(s_i\cap S)= \dim(S)-1$，注意到此时 $S\backslash s_i$ 也是简单的，此时直接 $f(S,i)=f(S\backslash s_i,i-1)+|S\cap s_i|\cdot v_i$ 即可。赛时相当于只想到这个转移。

特别的，对于 $\dim(s_i\cap S)= \dim(S)$，可以想见此时 $s_i\supseteq S$，那么 $f(S,i)=|S|\cdot v_i$ 即可。

### T4

如果取消我的最后一次更改的话，可以多拿两分。

首先第一问肯定是

$$
\begin{cases}
    1 & n\bmod 2=1\\
    2 & n\bmod 2=0
\end{cases}
$$

然后你发现对于 $n$ 为奇数的情况，一定是从中位数逐步扩展出来的。

对于 $n$ 为偶数，还需要枚举分割情况。

最终第二个样例都过不了就交上去了（没调出来），竟然拿了 $50.5$ 分，看了一眼第三问几乎没有对的，只能说部分分给得太慷慨了。