---
layout: default
title: 可爱多的字符串
permalink: /blog/ke-ai-duo-de-zi-fu-chuan/
---

## 可爱多的字符串

题意：令 $\mathrm{next}_i=\max\{x|0\le x<i,S[1,x]=S[i-x+1,i]\}$，每次询问子串带权 $\mathrm{next}$ 树深度和。
$$
\begin{aligned}
\mathtt{Ans}(l,r)&=\sum_{p=l}^r w_p\sum_{q=l}^{p-1} [\mathrm{LCP}(l,l+p-q)\ge q-l+1]\\
&=\sum_{q=l}^r \sum_{i=l+1}^{r+l-q} w_{i+q-l}[\mathrm{LCP}(l,i)\ge q-l+1]\\
&=\sum_{i=l+1}^r \sum_{j=0}^{\min(r-i,\mathrm{LCP}(l,i)-1)} w_{i+j}\\
&=\sum_{i=l+1}^r s_{\min(r,i+\mathrm{LCP}(l,i)-1)}-s_{i-1}
\end{aligned}
$$
其中 $s$ 是 $w$ 的前缀和。

后半部分是平凡的，我们着重处理 $\sum_{i=l+1}^r s_{\min(r,i+\mathrm{LCP}(l,i)-1)}$。

建立后缀树，即反串 SAM 的 parent 树，则 $\mathrm{LCP}(l,i)=\mathrm{len}_{\mathrm{LCA}(l,i)}$，则把这个问题完全转化为了树上 DS 问题。

然而 LCA 出现在了下标的下标中，这很诡异。考虑把 LCA 的可能性分类打包来算，不难想到重链剖分。

回忆重链剖分找 LCA 的过程，假设 $l$ 跳了一步轻边到了点 $u$，$i$ 跳了一步轻边到了点 $v$，要求两者的轻边不同，且 $u$ 和 $v$ 在一条重链上，则 $u$ 和 $v$ 中深度较小者为其 LCA。

轻边不同的要求可以简单地用容斥解决，因此贡献形如 $[l<i\le r]s_{\min(r,i+\min(\mathrm{len}_u,\mathrm{len}_v)-1)}$。

根据经验，把这一坨 $\min$ 拆成 $\min(r,i+\mathrm{len}_{u}-1,i+\mathrm{len}_v-1)$ 可以少分讨一次。

- 如果 $r\le i+\mathrm{len}_u-1$ 且 $r\le i+\mathrm{len}_v-1$，那么有 $\max(r-\mathrm{len}_u+1,l+1)\le i\le r$ 和 $i+\mathrm{len}_v-1\ge r$，每个 $i$ 的贡献为 $s_r$，这是一个二维数点问题，可以把询问离线后扫描线解决，总复杂度 $O(n\log^2 n)$。
- 剩下两种情况是一起搞的，因为分开讨论反而更难。如果 $i+\min(\mathrm{len}_u,\mathrm{len}_v)-1<r$，此时贡献形如 $s_{i+\min(\mathrm{len}_u,\mathrm{len}_v)-1}$，同时与 $l$ 跟 $i$ 相关，所以比较难搞。考虑回归字符串本质：注意到此时 $v$ 是在 $u$ 的子树内的，更进一步的，$i$ 也在 $u$ 的子树内，即 $u$ 是 $i$ 的一个前缀。那么，所有满足条件的 $i$ 是 $S[l,r)$ 中子串 $u$ 的匹配的左端点，而统计的贡献是其右端点。那么，直接把串反过来就可以了。具体地，在反串的后缀树中定位到 $u$（可以倍增跳父亲之类的），