---
layout: default
title: [省选联考 2025] 追忆
permalink: /blog/-sheng-xuan-lian-kao--2025--zhui-yi/
---

我常常追忆过去。

生命瞬间定格在脑海。我将背后的时间裁剪、折叠、蜷曲，揉捻成天上朵朵白云。

云朵之间亦有分别：积云厚重，而卷云飘渺。生命里震撼的场景掠过我的思绪便一生无法忘怀，而更为普通平常的记忆在时间的冲刷下只留下些许残骸。追忆宛如入梦，太过清楚则无法愉悦自己的幻想，过分模糊却又坠入虚无。只有薄雾间的暴力，面纱下的分块，那恰到好处的 bitset，才能满足我对美的苛求。

追忆总在不经意间将我裹进泛黄的纸页里。分别又重聚的朋友，推倒又重建的街道，种种线索协助着我从一个具体的时刻出发沿时间的河逆流而上。曾经的日子无法重来，我只不过是一个过客。但我仍然渴望在每一次追忆之旅中留下闲暇时间，在一个场景前驻足，在岁月的朦胧里瞭望过去的自己，感受尽可能多的甜蜜。美好的时光曾流过我的身体，我便心满意足。

过去已经凝固，我带着回忆向前，只是时常疏于保管，回忆也在改变着各自的形态。这给我的追忆旅程带来些许挑战。

我该在哪里停留？我问我自己。

# [省选联考 2025] 追忆

场上想了一个 DAG 上启发式合并的丑陋算法，而且复杂度是错的。

事实上关于 DAG 上的通达性的问题不存在有效的亚线性算法，所以我们可以直接把它当成黑盒。用 bitset 直接预处理出通达性。

当你看到没有出“图是一棵树”的部分分还有时间限制**6s**内存限制**2GB**的时候就应该想到啊……

一个思路是：询问时找出 $x$ 所能到达的所有点的集合、$a$ 值在 $[l,r]$ 的所有点的集合，两者与一下，然后求这个集合中 $b$ 值的最大值。

怎么求？朴素的想法是对每个 $i$ 求出 $b\ge i$ 的点的集合，然后二分找，但是这样二分时的复杂度就达到了不可承受的 $O(\frac nw\log n)$ 进行 $q$ 次。注意到我们是可以 $O(1)$ 判断合法的。所有我们可以对 $b$ 分块，二分确定在那个块内，然后块内暴力判断。

图是一个 DAG，所以直接拓扑排序就能预处理  $x$ 所能到达的所有点的集合，对 $a$ 分块，处理整块前缀和，可以找到 $a$ 值在 $[l,r]$ 的所有点的集合。

官方题解的做法是定期重构，待补。