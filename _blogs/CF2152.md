---
layout: default
title: CF2152
permalink: /blog/cf2152/
---

## A

数颜色

## B

Krug 每次往最远离 Doran 的方向走就是对的？

## C

你发现这个代价一般来说会**很小**？

具体的，只要它不是 01 间隔的形式，代价都能做到 1。

而如果出现这样的形式，可以以 2 的代价，创造一个长为 4 的连续段。

我们可以证明，如果出现 01 间隔地形式，那它只可能是一开始给出的。

因为我们消掉一个 1 会合并出两个连续段，从而形成一个链式反应。

所以只要分类讨论即可：

- 如果 0 或 1 的数量不是 3 的倍数，那么 -1
- 否则如果不存在 $a_i=a_{i+1},i\in[l,r)$，那么 $1+(r-l+1)/3$
- 否则 $(r-l+1)/3$

## D

显然 Bob 一定是优先操作较小的堆。

让我们关注二进制？ Alice 每次删掉最后一位，Bob 每次加 1。

如果 Bob 摆烂，那么 Alice 删完所有元素的步数为 $\sum_{i=1}^n\lfloor\log_2(a_i)\rfloor$。

所以 Bob 要尽其可能提高这个数？

注意到只要 Bob 抓准时机，他可以在任意位置加一个 1，除了最高位。

但是他每个位只能加一次，而且只能按顺序加，所以我们发现他只能让 $\lfloor\log_2(a_i)\rfloor$ 至多提高 $1$，而且能够提高 $1$ 当且仅当 $a_i$ 不是 $2$ 的幂。

...

## E

如果一次问到了一个长度为 $n+1$ 的递增子序列，那么直接返回它。

否则把这个子序列删掉，然后继续问。

如果一次都没有问到，那么一定至少问了 $\lceil\frac{n^2+1}{n}\rceil\ge n+1$ 次，然后每次的第一个元素拼起来一定是递减子序列。

然而这是错的，考虑 1 3 4 2 的情形，我们发现每组的第一个元素拼起来不一定是递减子序列……

考虑我们可用的信息是什么？

每个未被选的元素 $y$，找到前面第一个被选的元素 $x$，那么我们知道 $p_x>p_y$。

然后直接跑最长递减子序列。一定能找到解？有点神秘

```c++
#include<bits/stdc++.h>
#define ckmax(a,b) a=std::max(a,b)
const int N=1e5;
bool del[N],newdel[N];
std::pair<int,int> f[N];
std::vector<int> lim[N];
std::vector<int> b;
int main(){
    int T;scanf("%d",&T);
    while(T--){
        int n;scanf("%d",&n);
        int m=n*n+1;
        std::fill(del+1,del+m+1,0);
        std::fill(f+1,f+m+1,std::make_pair(1,0));
        for(int i=1;i<=m;i++) lim[i].clear();
        for(int t=1;t<=n;t++){
            b.clear();
            for(int i=1;i<=m;i++) if(!del[i]) b.push_back(i);
            printf("? %d ",(int)b.size());
            for(int i:b) printf("%d ",i);
            puts(""),fflush(stdout);
            int cnt;scanf("%d",&cnt);
            if(cnt>=n+1){
                b.clear();
                while(cnt--){int i;scanf("%d",&i);b.push_back(i);}
                printf("! ");
                for(int i=0;i<=n;i++) printf("%d ",b[i]);
                puts(""),fflush(stdout);
                goto Continue;
            }
            std::fill(newdel+1,newdel+m+1,0);
            while(cnt--){
                int j;scanf("%d",&j);del[j]=1;newdel[j]=1;
            }
            for(int i=1,las=0;i<=m;i++){
                if(!del[i]){
                    if(las){
                        if(lim[i].empty()||lim[i].back()!=las)
                        lim[i].push_back(las);
                    }
                }
                else if(newdel[i]) las=i;
            }
        }{
        int s=0;
        for(int i=1;i<=m;i++)
            for(int j:lim[i]) ckmax(f[i],std::make_pair(f[j].first+1,j));
        for(int i=1;i<=m;i++) if(f[i].first>=n+1) s=i;
        assert(s!=0);
        static std::stack<int> b;
        while(!b.empty()) b.pop();
        while(s) b.push(s),s=f[s].second;
        printf("! ");
        ++n;
        while(n--) printf("%d ",b.top()),b.pop();
        puts("");fflush(stdout);
        }Continue:;
    }
}
```

## F

貌似有一个经典的贪心解法？

从左到右扫，如果当前 $a_i-z$ 到 $a_i$ 有不少于 3 个数，那么优先弹掉 $a_i$ 是最优的。用一个滑动窗口维护即可。

或者另一种看法：用一个栈 $b$ 维护已被选的元素，如果 $b_{\mathrm{top}-1}+z<a_i$ 即可加入 $a_i$。

但是这个怎么维护区间信息？？？

考虑把 3 替换为 2 怎么做，这似乎是一个经典的问题，也就是说任意两个元素之间的距离都 $>z$。

记 $f_i$ 为 $i$ 后面第一个 $>a_i+z$ 的元素，那么可以倍增做。

那么这里能不能倍增呢？

我们发现，我们这里的约束，在栈的奇偶位上独立。

它形如两条互相缠绕的链，每条链上都满足「两个元素之间的距离 $>z$」的条件。

理想的情况是：取 $l$ 和 $l+1$ 作为链头，每次跳 $f$，然后就合法了。

显然「跳跃」的情况并不会发生，所以不合法意味着两条链发生重叠。

考虑对 $f$ 建树，如果 $l$ 与 $l+1$ 深度相等且 LCA $\le r$，那么将在 LCA 处发生重叠。

记 $i$ = LCA。那么其中一条链应当跳到 $i+1$，另一条链应当跳到 $\max(f_i,i+2)$。

这样直接模拟应该还是过不了。

还是预处理，考虑令 $g_i$ 表示 $i+1$ 和 $\max(f_i,i+2)$ 在何处相遇。

这样倍增套倍增应该就能过了。

## G

求黑点的虚树的叶子个数，其实就是数有多少个黑点的子树内没有别的黑点。

添加一个黑点，就是祖先路径覆盖为零，然后看一下子树内有没有黑点，没有的话就添加 1。

删除一个黑点，找到祖先内第一个黑点更新其状态，同时更新当前点状态。

貌似直接做就完了，核心部分在于找到祖先第一个黑点，树剖用一个线段树维护即可。

并非做完。

> To make this problem more challenging, you must also answer q
 queries. For each query, you are given a vertex v
. For each vertex w
 in the **subtree** of v
, its status is inverted — the one containing a monster starts to not contain one, and the one not containing a monster starts to contain one. After each query, you must solve the original problem again with the updated status.

下次还是得认真读题。

题意是子树翻转状态。

所以维护「我是黑点，子树内都是白点」和「我是白点，子树内都是黑点」的区间计数信息。同时维护「位置最大的黑点」和「位置最大的白点」。

然后就做完了。

## H

注意我们要染就一定会染一个连通块，所以 $f$ 就是所有的连通块中，点权和加上向外连的边权和最小的。

然后就是一个经典的树形 DP，记 $e_i$ 表示 $i$ 的父边的权值

$$
f_u=a_u+\sum_{v\in\mathrm{son}_u}\min(e_v,f_v)
$$

注意到我们的条件等价于 $\forall i,f_i+e_i\ge l$。

如果我们选择增大儿子的 $a$，确实能减少父亲的 $a$，但是不值。

所以我们按需索取即可。

$$
a_u=\max(0,l-e_u-\sum_{v\in \mathrm{son}_u}\min(e_v,f_v))
$$
$$
f_u=\max(\sum_{v\in\mathrm{son}_u}\min(e_v,f_v),l-e_u)
$$

然后 Easy Version 就做完了？

多次询问改变 $l$，所以不妨把 $l$ 视作自变量。

可以发现 $\sum_i a_i$ 是一个关于 $l$ 的分段线性增函数。

可以猜想 $a_u$ 或者 $f_u$ 的段数是 O(子树大小) 的，所以可以树上启发式合并，用一个 ODT 状物维护每一段的斜率？